# automake学习

## 资源
[官方手册](https://www.gnu.org/software/automake/manual/automake.html)

### 介绍

Automake is a tool for automatically generating Makefile.ins from files called Makefile.am. 

    Automake是一个用来将Makefile.in文件生成Makefile.am文件的工具。

Each Makefile.am is basically a series of make variable definitions, with rules being thrown in occasionally. 

    每个Makefile.am基本上都是一系列make变量定义，偶尔会抛出一些规则。 --- 有疑惑的翻译

The generated Makefile.ins are compliant with the GNU Makefile standards.

    生成的Makefile.ins符合GNU Makefile标准。

The GNU Makefile Standards Document (see [Makefile Conventions](https://www.gnu.org/prep/standards/standards.html#Makefile-Conventions) in The GNU Coding Standards) is long, complicated, and subject to change.

    GNU Makefile标准文档又长又复杂，还可能会更改。

The goal of Automake is to remove the burden of Makefile maintenance from the back of the individual GNU maintainer (and put it on the back of the Automake maintainers).

    Automake的目标是将Makefile维护的负担从单个GNU维护人员的背后移除(并将其放在Automake维护人员的背后)。

The typical Automake input file is simply a series of variable definitions. 

    典型的Automake输入文件只是一系列变量定义。

Each such file is processed to create a Makefile.in.

    每个文件被用来生成一个Makefile.in文件。

Automake does constrain a project in certain ways; 

    Automake以确定的方式约束了一个项目；

for instance, it assumes that the project uses Autoconf (see [Introduction](https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.70/autoconf.html#Top) in The Autoconf Manual), and enforces certain restrictions on the configure.ac contents.

    例如，它假设项目使用Autoconf，并对configure.ac内容实施某些限制。

Automake requires perl in order to generate the Makefile.ins.

    Automake需要Perl才能生成Makefile.ins。

However, the distributions created by Automake are fully GNU standards-compliant, and do not require perl in order to be built.

    但是Automake创建的发行版完全兼容GNU标准，并且不需要Perl即可构建。

## Autotools的介绍

If you are new to Automake, maybe you know that it is part of a set of tools called The Autotools. 

    如果您是第一次接触Automake，也许您知道它是一组名为AutoTools的工具的一部分。

Maybe you’ve already delved into a package full of files named configure, configure.ac, Makefile.in, Makefile.am, aclocal.m4, …, some of them claiming to be generated by Autoconf or Automake.

    也许您已经深入研究了一个包，其中包含名为Configure、configure.ac、Makefile.in、Makefile.am、aclocal.m4、等等这样的文件。你可以看到这些文件中一些声称是由Autoconf或Automake生成的。

But the exact purpose of these files and their relations is probably fuzzy.

    但这些文件的确切用途以及它们之间的关系可能是模糊的。

The goal of this chapter is to introduce you to this machinery, to show you how it works and how powerful it is.

    本章的目的是向您介绍这台机器，展示它是如何工作的，以及功能的强大。

If you’ve never installed or seen such a package, do not worry: this chapter will walk you through it.

    如果您从未安装或看到过这样的软件包，请不要担心：本章将带您了解它。

If you need some teaching material, more illustrations, or a less automake-centered continuation, some slides for this introduction are available in Alexandre Duret-Lutz’s [Autotools Tutorial](https://www.lrde.epita.fr/~adl/autotools.html).

    如果你需要一些教材，更多的插图，或者不是以automake为中心的延伸阅读，在Alexandre Duret-Lutz的Autotools教程中可以找到本简介的一些幻灯片。

This chapter is the written version of the first part of his tutorial.

    本章是他的教程第一部分的书面版本。

## GNU Build System介绍

It is a truth universally acknowledged, that as a developer in possession of a new package, you must be in want of a build system.

    作为一个拥有新软件包的开发人员，您肯定需要一个构建系统，这是一个举世公认的事实。

In the Unix world, such a build system is traditionally achieved using the command make (see [Overview](https://www.gnu.org/software/automake/manual/automake.html#Introduction) in The GNU Make Manual). 

    在Unix世界中，这样的构建系统传统上是使用make命令实现的。

You express the recipe to build your package in a Makefile. 

    您可以在Makefile中明确构建包的方法。

This file is a set of rules to build the files in the package. For instance the program prog may be built by running the linker on the files main.o, foo.o, and bar.o; the file main.o may be built by running the compiler on main.c; etc.

    此文件是在包中构建文件的一组规则。例如，程序prog可以通过在文件main.o、foo.o和bar.o上运行链接器来构建；文件main.o可以通过在main.c上运行编译器来构建；等等。

Each time make is run, it reads Makefile, checks the existence and modification time of the files mentioned, decides what files need to be built (or rebuilt), and runs the associated commands.

    每次运行make时，它都会读取Makefile，检查提到的文件是否存在和修改时间，决定需要构建(或重新构建)哪些文件，并运行相关的命令。

When a package needs to be built on a different platform than the one it was developed on, its Makefile usually needs to be adjusted. For instance the compiler may have another name or require more options. 

    当一个包需要构建在与开发它的平台不同的平台上时，它的Makefile通常需要调整。例如，编译器可能有另一个名称或需要更多选项。

In 1991, David J. MacKenzie got tired of customizing Makefile for the 20 platforms he had to deal with.

    1991年，David J.MacKenzie就因为需要为20个平台定制Makefile文件疯掉了。

Instead, he handcrafted a little shell script called configure to automatically adjust the Makefile (see [Genesis](https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.70/autoconf.html#Genesis) in The Autoconf Manual).

    相反，他手工创建了一个名为configure的小shell脚本来自动调整Makefile(参见Autoconf手册中的Genesis)。

Compiling his package was now as simple as running ./configure && make.

    编译他的包现只需要执行./configure && make就可以了。

Today this process has been standardized in the GNU project.

    现在这个过程已经在GNU项目中标准化了。

The GNU Coding Standards (see [The Release Process](https://www.gnu.org/prep/standards/standards.html#Managing-Releases) in The GNU Coding Standards) explains how each package of the GNU project should have a configure script, and the minimal interface it should have.

    GNU编码标准(参见GNU编码标准中的发布过程)解释了GNU项目的每个包应该如何拥有一个配置脚本，以及它应该具有的必要接口。

The Makefile too should follow some established conventions.

    Makefile也应该遵循一些既定的约定。

The result? A unified build system that makes all packages almost indistinguishable by the installer.

    结果是什么呢？一个统一的构建系统，使得安装程序几乎不用区分所有软件包。

 In its simplest scenario, all the installer has to do is to unpack the package, run ./configure && make && make install, and repeat with the next package to install.

    在其最简单的场景中，安装程序所需做的全部工作就是解压软件包，运行./configure && make &&make install，然后重复执行下一个要安装的软件包。

We call this build system the GNU Build System, since it was grown out of the GNU project.

    我们称这个构建系统为GNU构建系统，因为它是从GNU项目发展而来的。

However it is used by a vast number of other packages: following any existing convention has its advantages.

    然而，它被大量其他包使用：遵循任何现有的约定都有其优势。--- 有疑惑的翻译

The Autotools are tools that will create a GNU Build System for your package. 

    Autotools是为您的包创建GNU构建系统的工具。

Autoconf mostly focuses on configure and Automake on Makefiles.

    Autoconf主要专注于configure
    Automake主要专注于Makefile

It is entirely possible to create a GNU Build System without the help of these tools. 

    完全可以在没有这些工具的帮助下创建GNU构建系统。

However it is rather burdensome and error-prone. We will discuss this again after some illustration of the GNU Build System in action.

    然而，它相当繁重且容易出错。在对GNU构建系统进行一些实际演示之后，我们将再次讨论这个问题。

## GNU Build System举例

In this section we explore several use cases for the GNU Build System.

    在本节中，我们将探讨GNU构建系统的几个用例。

You can replay all of these examples on the amhello-1.0.tar.gz package distributed with Automake.

    您可以在Automake附带的amhello-1.0.tar.gz包中重现所有这些示例。

 If Automake is installed on your system, you should find a copy of this file in prefix/share/doc/automake/amhello-1.0.tar.gz

    如果你的系统装安装了Automake，你可以在prefix/share/doc/automake/amhello-1.0.tar.gz找到这个文件。

where prefix is the installation prefix specified during configuration (prefix defaults to /usr/local, however if Automake was installed by some GNU/Linux distribution it most likely has been set to /usr).

    prefix 是你在安装的时候定义的安装路径前缀，默认在/usr/local。但是有的发行版会在/usr中
    （比如译者的路径：/usr/share/doc/automake-1.13.4/amhello-1.0.tar.gz）

If you do not have a copy of Automake installed, you can find a copy of this file inside the doc/ directory of the Automake package.

    如果您没有安装Automake的副本，您可以在Automake软件包的doc/目录中找到该文件的副本。

Some of the following use cases present features that are in fact extensions to the GNU Build System.

    下面的一些用例提供了一些实际上是GNU构建系统扩展的特性。

Read: they are not specified by the GNU Coding Standards, but they are nonetheless part of the build system created by the Autotools.

    它们没有被GNU编码标准指定，但是它们仍然是由Autotools创建的构建系统的一部分。

To keep things simple, we do not point out the difference. Our objective is to show you many of the features that the build system created by the Autotools will offer to you.

    为了简单起见，我们没有指出区别。我们的目标是展示AutoTools创建的构建系统提供的功能。

## Basic Installation

The most common installation procedure looks as follows.

    最常见的安装过程如下所示。

[![asciicast](https://asciinema.org/a/6EDtdRm9x0zo8ChMIxDrHVVgO.svg)](https://asciinema.org/a/6EDtdRm9x0zo8ChMIxDrHVVgO)

The user first unpacks the package. Here, and in the following examples, we will use the non-portable tar zxf command for simplicity. 

    用户首先打开包裹。为了简单起见，在这里和下面的示例中，我们将使用不可移植的tar zxf命令。

On a system without GNU tar installed, this command should read gunzip -c amhello-1.0.tar.gz | tar xf -.

    在没有安装GNU tar的系统上，该命令应该是 gunzip -c amhello-1.0.tar.gz | tar xf -

The user then enters the newly created directory to run the configure script. 

    用户然后进入新创建的目录运行configure脚本。

This script probes the system for various features, and finally creates the MakefileS.

    该脚本探测系统的各种功能，并最终创建Makefile文件。

In this toy example there are only two MakefileS, but in real-world projects, there may be many more, usually one Makefile per directory.

    在这个玩具示例中，只有两个Makefile(译者注：根目录一个，src目录一个)，但在现实世界的项目中，可能有更多，通常每个目录一个Makefile。

It is now possible to run make. This will construct all the programs, libraries, and scripts that need to be constructed for the package. 

    现在可以运行make了。这将为包构建所有的程序、库和脚本。

In our example, this compiles the hello program. All files are constructed in place, in the source tree; we will see later how this can be changed.

    在我们的示例中，这将编译hello程序。所有文件都在源代码树中构建到位；我们稍后将看到如何更改这一点。