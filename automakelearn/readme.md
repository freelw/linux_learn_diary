# automake学习

## 资源
[官方手册](https://www.gnu.org/software/automake/manual/automake.html)

### 介绍

Automake is a tool for automatically generating Makefile.ins from files called Makefile.am. 

    Automake是一个用来将Makefile.in文件生成Makefile.am文件的工具。

Each Makefile.am is basically a series of make variable definitions, with rules being thrown in occasionally. 

    每个Makefile.am基本上都是一系列make变量定义，偶尔会抛出一些规则。 --- 有疑惑的翻译

The generated Makefile.ins are compliant with the GNU Makefile standards.

    生成的Makefile.ins符合GNU Makefile标准。

The GNU Makefile Standards Document (see [Makefile Conventions](https://www.gnu.org/prep/standards/standards.html#Makefile-Conventions) in The GNU Coding Standards) is long, complicated, and subject to change.

    GNU Makefile标准文档又长又复杂，还可能会更改。

The goal of Automake is to remove the burden of Makefile maintenance from the back of the individual GNU maintainer (and put it on the back of the Automake maintainers).

    Automake的目标是将Makefile维护的负担从单个GNU维护人员的背后移除(并将其放在Automake维护人员的背后)。

The typical Automake input file is simply a series of variable definitions. 

    典型的Automake输入文件只是一系列变量定义。

Each such file is processed to create a Makefile.in.

    每个文件被用来生成一个Makefile.in文件。

Automake does constrain a project in certain ways; 

    Automake以确定的方式约束了一个项目；

for instance, it assumes that the project uses Autoconf (see [Introduction](https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.70/autoconf.html#Top) in The Autoconf Manual), and enforces certain restrictions on the configure.ac contents.

    例如，它假设项目使用Autoconf，并对configure.ac内容实施某些限制。

Automake requires perl in order to generate the Makefile.ins.

    Automake需要Perl才能生成Makefile.ins。

However, the distributions created by Automake are fully GNU standards-compliant, and do not require perl in order to be built.

    但是Automake创建的发行版完全兼容GNU标准，并且不需要Perl即可构建。

## Autotools的介绍

If you are new to Automake, maybe you know that it is part of a set of tools called The Autotools. 

    如果您是第一次接触Automake，也许您知道它是一组名为AutoTools的工具的一部分。

Maybe you’ve already delved into a package full of files named configure, configure.ac, Makefile.in, Makefile.am, aclocal.m4, …, some of them claiming to be generated by Autoconf or Automake.

    也许您已经深入研究了一个包，其中包含名为Configure、configure.ac、Makefile.in、Makefile.am、aclocal.m4、等等这样的文件。你可以看到这些文件中一些声称是由Autoconf或Automake生成的。

But the exact purpose of these files and their relations is probably fuzzy.

    但这些文件的确切用途以及它们之间的关系可能是模糊的。

The goal of this chapter is to introduce you to this machinery, to show you how it works and how powerful it is.

    本章的目的是向您介绍这台机器，展示它是如何工作的，以及功能的强大。

If you’ve never installed or seen such a package, do not worry: this chapter will walk you through it.

    如果您从未安装或看到过这样的软件包，请不要担心：本章将带您了解它。

If you need some teaching material, more illustrations, or a less automake-centered continuation, some slides for this introduction are available in Alexandre Duret-Lutz’s [Autotools Tutorial](https://www.lrde.epita.fr/~adl/autotools.html).

    如果你需要一些教材，更多的插图，或者不是以automake为中心的延伸阅读，在Alexandre Duret-Lutz的Autotools教程中可以找到本简介的一些幻灯片。

This chapter is the written version of the first part of his tutorial.

    本章是他的教程第一部分的书面版本。

## GNU Build System介绍

It is a truth universally acknowledged, that as a developer in possession of a new package, you must be in want of a build system.

    作为一个拥有新软件包的开发人员，您肯定需要一个构建系统，这是一个举世公认的事实。

In the Unix world, such a build system is traditionally achieved using the command make (see [Overview](https://www.gnu.org/software/automake/manual/automake.html#Introduction) in The GNU Make Manual). 

    在Unix世界中，这样的构建系统传统上是使用make命令实现的。

You express the recipe to build your package in a Makefile. 

    您可以在Makefile中明确构建包的方法。

This file is a set of rules to build the files in the package. For instance the program prog may be built by running the linker on the files main.o, foo.o, and bar.o; the file main.o may be built by running the compiler on main.c; etc.

    此文件是在包中构建文件的一组规则。例如，程序prog可以通过在文件main.o、foo.o和bar.o上运行链接器来构建；文件main.o可以通过在main.c上运行编译器来构建；等等。

Each time make is run, it reads Makefile, checks the existence and modification time of the files mentioned, decides what files need to be built (or rebuilt), and runs the associated commands.

    每次运行make时，它都会读取Makefile，检查提到的文件是否存在和修改时间，决定需要构建(或重新构建)哪些文件，并运行相关的命令。

When a package needs to be built on a different platform than the one it was developed on, its Makefile usually needs to be adjusted. For instance the compiler may have another name or require more options. 

    当一个包需要构建在与开发它的平台不同的平台上时，它的Makefile通常需要调整。例如，编译器可能有另一个名称或需要更多选项。

In 1991, David J. MacKenzie got tired of customizing Makefile for the 20 platforms he had to deal with.

    1991年，David J.MacKenzie就因为需要为20个平台定制Makefile文件疯掉了。

Instead, he handcrafted a little shell script called configure to automatically adjust the Makefile (see [Genesis](https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.70/autoconf.html#Genesis) in The Autoconf Manual).

    相反，他手工创建了一个名为configure的小shell脚本来自动调整Makefile(参见Autoconf手册中的Genesis)。

Compiling his package was now as simple as running ./configure && make.

    编译他的包现只需要执行./configure && make就可以了。

Today this process has been standardized in the GNU project.

    现在这个过程已经在GNU项目中标准化了。

The GNU Coding Standards (see [The Release Process](https://www.gnu.org/prep/standards/standards.html#Managing-Releases) in The GNU Coding Standards) explains how each package of the GNU project should have a configure script, and the minimal interface it should have.

    GNU编码标准(参见GNU编码标准中的发布过程)解释了GNU项目的每个包应该如何拥有一个配置脚本，以及它应该具有的必要接口。

The Makefile too should follow some established conventions.

    Makefile也应该遵循一些既定的约定。

The result? A unified build system that makes all packages almost indistinguishable by the installer.

    结果是什么呢？一个统一的构建系统，使得安装程序几乎不用区分所有软件包。

 In its simplest scenario, all the installer has to do is to unpack the package, run ./configure && make && make install, and repeat with the next package to install.

    在其最简单的场景中，安装程序所需做的全部工作就是解压软件包，运行./configure && make &&make install，然后重复执行下一个要安装的软件包。

We call this build system the GNU Build System, since it was grown out of the GNU project.

    我们称这个构建系统为GNU构建系统，因为它是从GNU项目发展而来的。

However it is used by a vast number of other packages: following any existing convention has its advantages.

    然而，它被大量其他包使用：遵循任何现有的约定都有其优势。--- 有疑惑的翻译

The Autotools are tools that will create a GNU Build System for your package. 

    Autotools是为您的包创建GNU构建系统的工具。

Autoconf mostly focuses on configure and Automake on Makefiles.

    Autoconf主要专注于configure
    Automake主要专注于Makefile

It is entirely possible to create a GNU Build System without the help of these tools. 

    完全可以在没有这些工具的帮助下创建GNU构建系统。

However it is rather burdensome and error-prone. We will discuss this again after some illustration of the GNU Build System in action.

    然而，它相当繁重且容易出错。在对GNU构建系统进行一些实际演示之后，我们将再次讨论这个问题。

## GNU Build System举例

In this section we explore several use cases for the GNU Build System.

    在本节中，我们将探讨GNU构建系统的几个用例。

You can replay all of these examples on the amhello-1.0.tar.gz package distributed with Automake.

    您可以在Automake附带的amhello-1.0.tar.gz包中重现所有这些示例。

 If Automake is installed on your system, you should find a copy of this file in prefix/share/doc/automake/amhello-1.0.tar.gz

    如果你的系统装安装了Automake，你可以在prefix/share/doc/automake/amhello-1.0.tar.gz找到这个文件。

where prefix is the installation prefix specified during configuration (prefix defaults to /usr/local, however if Automake was installed by some GNU/Linux distribution it most likely has been set to /usr).

    prefix 是你在安装的时候定义的安装路径前缀，默认在/usr/local。但是有的发行版会在/usr中
    （比如译者的路径：/usr/share/doc/automake-1.13.4/amhello-1.0.tar.gz）

If you do not have a copy of Automake installed, you can find a copy of this file inside the doc/ directory of the Automake package.

    如果您没有安装Automake的副本，您可以在Automake软件包的doc/目录中找到该文件的副本。

Some of the following use cases present features that are in fact extensions to the GNU Build System.

    下面的一些用例提供了一些实际上是GNU构建系统扩展的特性。

Read: they are not specified by the GNU Coding Standards, but they are nonetheless part of the build system created by the Autotools.

    它们没有被GNU编码标准指定，但是它们仍然是由Autotools创建的构建系统的一部分。

To keep things simple, we do not point out the difference. Our objective is to show you many of the features that the build system created by the Autotools will offer to you.

    为了简单起见，我们没有指出区别。我们的目标是展示AutoTools创建的构建系统提供的功能。

## Basic Installation

The most common installation procedure looks as follows.

    最常见的安装过程如下所示。

[![asciicast](https://asciinema.org/a/6EDtdRm9x0zo8ChMIxDrHVVgO.svg)](https://asciinema.org/a/6EDtdRm9x0zo8ChMIxDrHVVgO)

The user first unpacks the package. Here, and in the following examples, we will use the non-portable tar zxf command for simplicity. 

    用户首先打开包裹。为了简单起见，在这里和下面的示例中，我们将使用不可移植的tar zxf命令。

On a system without GNU tar installed, this command should read gunzip -c amhello-1.0.tar.gz | tar xf -.

    在没有安装GNU tar的系统上，该命令应该是 gunzip -c amhello-1.0.tar.gz | tar xf -

The user then enters the newly created directory to run the configure script. 

    用户然后进入新创建的目录运行configure脚本。

This script probes the system for various features, and finally creates the MakefileS.

    该脚本探测系统的各种功能，并最终创建Makefile文件。

In this toy example there are only two MakefileS, but in real-world projects, there may be many more, usually one Makefile per directory.

    在这个玩具示例中，只有两个Makefile(译者注：根目录一个，src目录一个)，但在现实世界的项目中，可能有更多，通常每个目录一个Makefile。

It is now possible to run make. This will construct all the programs, libraries, and scripts that need to be constructed for the package. 

    现在可以运行make了。这将为包构建所有的程序、库和脚本。

In our example, this compiles the hello program. All files are constructed in place, in the source tree; we will see later how this can be changed.

    在我们的示例中，这将编译hello程序。所有文件都在源代码树中构建到位；我们稍后将看到如何更改这一点。

make check causes the package’s tests to be run. 

    make check 命令触发包运行测试用例。

This step is not mandatory, but it is often good to make sure the programs that have been built behave as they should, before you decide to install them.

    这一步不是强制性的，但在您决定安装程序之前最好还是执行一下确保构建出来的程序运行正确。

Our example does not contain any tests, so running make check is a no-op.

    我们的例子中没有任何测试用例，所以make check命令什么也不执行。

After everything has been built, and maybe tested, it is time to install it on the system.

    在构建好一切并可能进行测试之后，就可以将其安装到系统上了。

That means copying the programs, libraries, header files, scripts, and other data files from the source directory to their final destination on the system. 

    这意味着将程序、库、头文件、脚本和其他数据文件从源目录复制到它们在系统上的最终目标。

The command make install will do that.

    make install 命令会做这些事情。

However, by default everything will be installed in subdirectories of /usr/local: binaries will go into /usr/local/bin, libraries will end up in /usr/local/lib, etc.

    默认情况下，所有东西都会被安装到/usr/local：例如二进制文件会安装到/usr/local/bin，库文件会安装到/usr/local/lib

This destination is usually not writable by any user, so we assume that we have to become root before we can run make install. 

    目标路径一般不能被任何用户写，所以我们要确保是以root权限运行make install命令。

In our example, running make install will copy the program hello into /usr/local/bin and README into /usr/local/share/doc/amhello.

    在我们的例子中，执行make install命令会把hello拷贝到/usr/local/bin中，把README拷贝到/usr/local/share/doc/amhello中

[![asciicast](https://asciinema.org/a/Eal6GkoGY7R92MsalpYgMSG1t.svg)](https://asciinema.org/a/Eal6GkoGY7R92MsalpYgMSG1t)

A last and optional step is to run make installcheck. 

    最后一个可选步骤是执行make installcheck命令。

This command may run tests on the installed files. 

    这个命令会在已经安装的文件上跑测试用例。

make check tests the files in the source tree, while make installcheck tests their installed copies. 

    make check命令会在源文件目录树中跑测试用例，而make installcheck会测试已经安装好的文件。

The tests run by the latter can be different from those run by the former.

    后者运行的测试可以与前者运行的测试不同。

For instance, there are tests that cannot be run in the source tree. 

    例如，有些测试不能在源文件目录树中运行。

Conversely, some packages are set up so that make installcheck will run the very same tests as make check, only on different files (non-installed vs. installed).

    但是也有一些软件包在这两种情况下会运行相同的测试用例，只是目标文件不同而已。

It can make a difference, for instance when the source tree’s layout is different from that of the installation.

    当源代码树的布局与安装的布局不同时，运行情况可能会有所不同。

Furthermore it may help to diagnose an incomplete installation.

    此外，这种方式有助于诊断安装是否完整。

Presently most packages do not have any installcheck tests because the existence of installcheck is little known, and its usefulness is neglected.

    目前大多数软件包没有任何安装检查测试，因为安装检查的存在鲜为人知，其有用性被忽视。

Our little toy package is no better: make installcheck does nothing.

    我们的小玩具包也好不到哪里去：make installcheck什么也不做。

## Standard Makefile Targets

So far we have come across four ways to run make in the GNU Build System: make, make check, make install, and make installcheck. 

    到目前为止，我们已经遇到了四种在GNU构建系统中运行make的方法：make、make check、make install和make installcheck。

The words check, install, and installcheck, passed as arguments to make, are called targets. 

    命令字check、install和作为参数传递给make，称为目标。

make is a shorthand for make all, all being the default target in the GNU Build System.
    Make是make all的缩写，all是GNU构建系统中的默认目标。

Here is a list of the most useful targets that the GNU Coding Standards specify.

    下面是GNU编码标准指定的最有用的目标列表。

make all

    Build programs, libraries, documentation, etc. (same as make).
    构建程序、库、文档等(与make相同)。

make install

    Install what needs to be installed, copying the files from the package’s tree to system-wide directories.
    安装需要安装的内容，将文件从软件包的树复制到系统范围的目录。

make install-strip

    Same as make install, then strip debugging symbols. Some users like to trade space for useful bug reports...
    与make install相同，然后剥离调试符号。一些用户喜欢用空间换取有用的错误报告……

make uninstall

    The opposite of make install: erase the installed files. (This needs to be run from the same build tree that was installed.)
    与make install相反：删除已安装的文件。(这需要从安装的同一构建树中运行。)

make clean

    Erase from the build tree the files built by make all.
    从构建树中删除由make all构建的文件。

make distclean

    Additionally erase anything ./configure created.
    额外删除./configure命令生成的文件。

make check

    Run the test suite, if any.
    如果有测试用例就运行。

make installcheck

    Check the installed programs or libraries, if supported.
    检查已安装的程序或库(如果支持)。

make dist

    Recreate package-version.tar.gz from all the source files.
    从所有源文件重新创建package-version.tar.gz。

## Standard Directory Variables
The GNU Coding Standards also specify a hierarchy of variables to denote installation directories. Some of these are:

    GNU编码标准还指定了变量层次结构来表示安装目录。其中一些是：

    Directory variable	Default value
    prefix	/usr/local
    exec_prefix	${prefix}
        bindir	${exec_prefix}/bin
        libdir	${exec_prefix}/lib
        …
    includedir	${prefix}/include
    datarootdir	${prefix}/share
        datadir	${datarootdir}
        mandir	${datarootdir}/man
        infodir	${datarootdir}/info
        docdir	${datarootdir}/doc/${PACKAGE}

Each of these directories has a role which is often obvious from its name.

    这些目录中的每一个都具有从其名称中通常可以明显看出的作用。

In a package, any installable file will be installed in one of these directories.

    在软件包中，任何可安装文件都将安装在这些目录之一中。

For instance in amhello-1.0, the program hello is to be installed in bindir, the directory for binaries.

    例如，在amhello-1.0中，程序hello将安装在bin
    中，这是二进制文件的目录。

The default value for this directory is /usr/local/bin, but the user can supply a different value when calling configure.

    该目录的默认值是/usr/local/bin，但是用户可以在调用configure时提供一个不同的值。

Also the file README will be installed into docdir, which defaults to /usr/local/share/doc/amhello.

    此外，自述文件将安装到doc目录中，该目录默认为/usr/local/share/doc/amhello。

As a user, if you wish to install a package on your own account, you could proceed as follows:

    作为用户，如果您希望自己安装软件包，可以按照以下步骤操作：

    ~/amhello-1.0 % ./configure --prefix ~/usr
    …
    ~/amhello-1.0 % make
    …
    ~/amhello-1.0 % make install
    …

This would install ~/usr/bin/hello and ~/usr/share/doc/amhello/README.

    这将安装~/usr/bin/hello和~/usr/share/doc/amhello/readme。

The list of all such directory options is shown by ./configure --help.

    这样的目录选项可以通过./configure --help查询。

## Standard Configuration Variables

The GNU Coding Standards also define a set of standard configuration variables used during the build. Here are some:

    GNU编码标准还定义了构建期间使用的一组标准环境变量。
    这里有一些：

    CC
        C compiler command

    CFLAGS
        C compiler flags

    CXX
        C++ compiler command

    CXXFLAGS
        C++ compiler flags

    LDFLAGS
        linker flags

    CPPFLAGS
        C/C++ preprocessor flags

configure usually does a good job at setting appropriate values for these variables, but there are cases where you may want to override them. 

    configure通常可以很好地为这些变量设置适当的值，但在某些情况下，你可能想要覆盖它们。

For instance you may have several versions of a compiler installed and would like to use another one, you may have header files installed outside the default search path of the compiler, or even libraries out of the way of the linker.

    例如，你可能安装了多个版本的编译器并希望使用另一个版本，你可能将头文件安装在编译器的默认搜索路径之外，甚至可能安装了链接器之外的库。

Here is how one would call configure to force it to use gcc-3 as C compiler, use header files from ~/usr/include when compiling, and libraries from ~/usr/lib when linking.

    下面是如何调用configure强制它使用gcc-3作为C编译器，编译时使用~/usr/include中的头文件，链接时使用~/usr/lib中的库。

    ~/amhello-1.0 % ./configure --prefix ~/usr CC=gcc-3 \
    CPPFLAGS=-I$HOME/usr/include LDFLAGS=-L$HOME/usr/lib

Again, a full list of these variables appears in the output of ./configure --help.

    同样，这些变量的完整列表显示在./configure--help的输出中。

##Overriding Default Configuration Setting with config.site

When installing several packages using the same setup, it can be convenient to create a file to capture common settings.

    当使用相同的配置安装多个软件包时，创建一个文件来捕获公共设置会很方便。

If a file named prefix/share/config.site exists, configure will source it at the beginning of its execution.

    如果存在名为prefix/share/config.site的文件，则configure将在其执行开始时将source这个文件。

Recall the command from the previous section:

    回想上一节中的命令：

    ~/amhello-1.0 % ./configure --prefix ~/usr CC=gcc-3 \
    CPPFLAGS=-I$HOME/usr/include LDFLAGS=-L$HOME/usr/libs

Assuming we are installing many package in ~/usr, and will always want to use these definitions of CC, CPPFLAGS, and LDFLAGS, we can automate this by creating the following

    假设我们在~/usr中安装了许多软件包，并且总是希望使用CC、CPPFLAGS和LDFLAGS的这些定义，我们可以通过创建以下内容来实现自动化
    
    ~/usr/share/config.site file:
    test -z "$CC" && CC=gcc-3
    test -z "$CPPFLAGS" && CPPFLAGS=-I$HOME/usr/include
    test -z "$LDFLAGS" && LDFLAGS=-L$HOME/usr/lib

Now, any time a configure script is using the ~/usr prefix, it will execute the above config.site and define these three variables.

    现在，只要配置脚本使用~/usr前缀，它就会执行上面的config.site并定义这三个变量。

    ~/amhello-1.0 % ./configure --prefix ~/usr
    configure: loading site script /home/adl/usr/share/config.site
    …

See [Setting Site Defaults](https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.70/autoconf.html#Site-Defaults) in The Autoconf Manual, for more information about this feature.

## Parallel Build Trees (a.k.a. VPATH Builds) 并行构建树

The GNU Build System distinguishes two trees: the source tree, and the build tree. These are two directories that may be the same, or different.

    GNU构建系统区分两个树：源树和构建树。这两个目录可能相同，也可能不同。

The source tree is rooted in the directory containing the configure script. It contains all the source files (those that are distributed), and may be arranged using several subdirectories.

    源树位于包含配置脚本的目录中。它包含所有源文件(那些分发的源文件)，并且可以使用几个子目录进行排列。

The build tree is rooted in the current directory at the time configure was run, and is populated with all object files, programs, libraries, and other derived files built from the sources (and hence not distributed).

    构建树以configure运行时的当前目录为根，并填充了所有目标文件、程序、库和从源代码构建的其他派生文件(派生的文件不是分发的是生成的)。

The build tree usually has the same subdirectory layout as the source tree; its subdirectories are created automatically by the build system.

    构建树通常与源树具有相同的子目录布局；其子目录由构建系统自动创建。

If configure is executed in its own directory, the source and build trees are combined: derived files are constructed in the same directories as their sources. 

    如果在其自己的目录中执行configure，则源文件和构建树是同一个：派生文件在和源文件相同的目录中构建处理啊。

This was the case in our first installation example (see Basic Installation).

    这就是我们的第一个安装示例中的情况(请参见Basic Installation)。

A common request from users is that they want to confine all derived files to a single directory, to keep their source directories uncluttered. 

    用户的一个常见要求是，他们希望将所有派生文件限制在单个目录中，以保持其源目录的整洁。

Here is how we could run configure to create everything in a build tree (that is, subdirectory) called build/.

    下面是我们如何运行configure来在build目录中构建build tree

    ~ % tar zxf ~/amhello-1.0.tar.gz
    ~ % cd amhello-1.0
    ~/amhello-1.0 % mkdir build && cd build
    ~/amhello-1.0/build % ../configure
    …
    ~/amhello-1.0/build % make
    …

These setups, where source and build trees are different, are often called parallel builds or VPATH builds. 

    这种源树和构建树不同的构建行为被称为parallel builds或者VPATH builds。

The expression parallel build is misleading: the word parallel is a reference to the way the build tree shadows the source tree, it is not about some concurrency in the way build commands are run.

    parallel build 这种表达比较有误导性：“并行”一词指的是构建树对源树的影响方式，它与构建命令运行方式中的某些并发性无关。

For this reason we refer to such setups using the name VPATH builds in the following.

    出于这个原因，我们在下面使用名称VPATH build来指代这样的设置。

VPATH is the name of the make feature used by the Makefiles to allow these builds (see VPATH Search [Path for All Prerequisites](https://www.gnu.org/software/make/manual/make.html#General-Search) in The GNU Make Manual).

    VPATH是关于这个特性的环境变量，见链接。

##### 临时插入VPATH的解释
###### VPATH: Search Path for All Prerequisites
[资源](https://www.gnu.org/software/make/manual/make.html#General-Search)


The value of the make variable VPATH specifies a list of directories that make should search.

    VPATH指定一个目录列表，make在这个列表中去搜索。

Most often, the directories are expected to contain prerequisite files that are not in the current directory; however, make uses VPATH as a search list for both prerequisites and targets of rules.

    通常，这些目录应该包含不在当前目录中的先决条件文件；
    make使用VPATH作为先决条件和目标的搜索列表。

Thus, if a file that is listed as a target or prerequisite does not exist in the current directory, make searches the directories listed in VPATH for a file with that name.

    因此，如果当前目录中不存在被列为目标或先决条件的文件，则make将在VPATH中列出的目录中搜索具有该名称的文件。

Rules may then specify the names of files in the prerequisite list as if they all existed in the current directory.

    然后，规则可以指定先决条件列表中的文件名，就好像它们都存在于当前目录中一样。

In the VPATH variable, directory names are separated by colons or blanks. The order in which directories are listed is the order followed by make in its search.

    在VPATH变量中，目录名称用冒号或空格分隔。
    make 按照名字出现的先后顺序去搜索。

例如：

    VPATH = src:../headers

    指定两个搜索路径 src 和 ../headers

    foo.o : foo.c

    这时上面的这条规则被转化成这样

    foo.o : src/foo.c
##### 从VPATH的解释返回回来

VPATH builds have other interesting uses. One is to build the same sources with multiple configurations. For instance:

    VPATH构建还有其他有趣的用途。一种是使用多个配置构建相同的源代码。例如：

    ~ % tar zxf ~/amhello-1.0.tar.gz
    ~ % cd amhello-1.0
    ~/amhello-1.0 % mkdir debug optim && cd debug
    ~/amhello-1.0/debug % ../configure CFLAGS='-g -O0'
    …
    ~/amhello-1.0/debug % make
    …
    ~/amhello-1.0/debug % cd ../optim
    ~/amhello-1.0/optim % ../configure CFLAGS='-O3 -fomit-frame-pointer'
    …
    ~/amhello-1.0/optim % make
    …

With network file systems, a similar approach can be used to build the same sources on different machines. 

    对于网络文件系统，可以使用类似的方法在不同的机器上构建相同的源代码。

For instance, suppose that the sources are installed on a directory shared by two hosts: HOST1 and HOST2, which may be different platforms.

    例如，假设源码安装在由两台主机共享的目录上：HOST1和HOST2，这两台主机可能是不同的平台。

    ~ % cd /nfs/src
    /nfs/src % tar zxf ~/amhello-1.0.tar.gz

On the first host, you could create a local build directory:

    在第一台主机上，你可以创建本地构建目录：

    [HOST1] ~ % mkdir /tmp/amh && cd /tmp/amh
    [HOST1] /tmp/amh % /nfs/src/amhello-1.0/configure
    ...
    [HOST1] /tmp/amh % make && sudo make install
    ...

On the second host, you would do exactly the same, possibly at the same time:

    在第二台主机上，你可能会同时执行完全相同的操作：

    [HOST2] ~ % mkdir /tmp/amh && cd /tmp/amh
    [HOST2] /tmp/amh % /nfs/src/amhello-1.0/configure
    ...
    [HOST2] /tmp/amh % make && sudo make install
    ...

In this scenario, nothing forbids the /nfs/src/amhello-1.0 directory from being read-only.

    在这种场景下，其实/nfs/src/amhello-1.0目录完全是可以只读的。

In fact VPATH builds are also a means of building packages from a read-only medium such as a CD-ROM. (The FSF used to sell CD-ROMs with unpacked source code, before the GNU project grew so big.)

    事实上，VPATH构建也是从CD-ROM等只读介质构建包的一种方法。(在GNU项目变得如此庞大之前，FSF过去销售的是未打包源代码的CD-ROM。)

## Two-Part Installation

In our last example (see VPATH Builds), a source tree was shared by two hosts, but compilation and installation were done separately on each host.

    在我们的上一个示例(参见VPATH构建)中，源树由两台主机共享，但编译和安装是在每台主机上单独完成的。

The GNU Build System also supports networked setups where part of the installed files should be shared amongst multiple hosts.

    GNU构建系统还支持联网安装，其中应在多个主机之间共享部分已安装的文件。

It does so by distinguishing architecture-dependent files from architecture-independent files, and providing two Makefile targets to install each of these classes of files.

    它通过区分依赖于体系结构的文件和独立于体系结构的文件来实现这一点，并提供两个Makefile目标来安装这些类文件中的每一个。

These targets are install-exec for architecture-dependent files and install-data for architecture-independent files.

    目标 install-exec 跟体系结构相关
    目标 install-data 跟体系结构无关

The command we used up to now, make install, can be thought of as a shorthand for make install-exec install-data.

    到目前为止，我们使用的命令make install可以看作是make install-exec install-data的简写。

From the GNU Build System point of view, the distinction between architecture-dependent files and architecture-independent files is based exclusively on the directory variable used to specify their installation destination. 

    从GNU构建系统的角度来看，依赖于体系结构的文件和不依赖体系结构的文件之间的区别就是目标目录变量。

